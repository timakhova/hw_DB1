Домашнее задание к занятию «Базы данных, их типы» Тимахова Наталья

Задание 1. СУБД

1.1. Бюджетирование проектов с финансовыми отчётами и прогнозированием рисков
Для решения задач, связанных с бюджетированием и финансовыми аналитическими отчетами, лучшим выбором будет реляционная СУБД, например, PostgreSQL или Oracle. Эти СУБД поддерживают ACID-транзакции, обеспечивая целостность данных, а также имеют продвинутые возможности для работы с аналитикой и сложными запросами. Они хорошо подходят для структурированных данных, требующих высокой точности и надежности. Также можно использовать системы с OLAP (Online Analytical Processing), которые упрощают построение аналитических отчетов.

1.1.* Оптимизация хеширования
Если хеширование занимает слишком много времени, можно использовать API, такие как bcrypt, scrypt, или Argon2, которые обеспечивают безопасное и оптимизированное хеширование. Также возможно использовать библиотеки для работы с асинхронным хешированием, что может улучшить производительность, например, на базе C/C++ или Rust.

1.2. Лендинги и CRM
Для лендингов и CRM лучше всего использовать нереляционные, но гибкие и масштабируемые СУБД. Для лендингов может подойти MongoDB (документо-ориентированная СУБД), которая поддерживает быструю запись и обработку данных. Для CRM-системы можно рассмотреть MySQL или PostgreSQL, так как CRM обычно требует структурированной обработки данных с возможностью сложных запросов.

1.2.* Закрытие задачи одной СУБД
Теоретически, можно использовать одну СУБД для обеих задач, если применить PostgreSQL с гибридным подходом (она поддерживает как реляционную структуру для CRM, так и JSON-формат для хранения данных лендингов). Однако в зависимости от нагрузки и специфики задач может быть целесообразно разделить данные на разные системы.

1.3. База для отдела контроля качества
Для структуры компании и нормативной базы можно использовать реляционную СУБД, например, MySQL или PostgreSQL. Они обеспечат простоту в работе с документами, нормами и корпоративными данными, обеспечивая четкую иерархию и управление доступом.

1.3.* Использование существующей СУБД
Для этой задачи можно использовать ту же СУБД, что и для задач бюджетирования (например, PostgreSQL). Важно лишь разделить базы данных или использовать разные схемы для логического отделения данных по задачам. Это обеспечит легкость управления и интеграцию с другими отделами.

1.4. Логистика: маршруты и курьеры
Для задач, связанных с логистикой, хорошо подойдут графовые СУБД, такие как Neo4j или ArangoDB, которые специально оптимизированы для работы с графами и связями. Они позволяют эффективно находить оптимальные маршруты и управлять связями между объектами.

1.4.* Интеграция отдела закупок
Отдел закупок можно подключить к той же графовой СУБД, так как процессы логистики и закупок часто имеют пересечения (например, маршруты доставки материалов и их закупка). Это позволит централизованно управлять процессами.

1.5.* Решение задач с одной СУБД
Теоретически можно решить все задачи с помощью одной СУБД, если выбрать PostgreSQL, так как она поддерживает как реляционную модель, так и JSON-данные для менее структурированных данных (например, лендингов и CRM). Однако для задач логистики (графовые данные) может потребоваться либо расширение функциональности PostgreSQL через плагины, такие как pgRouting, либо всё же использование специализированной графовой СУБД (Neo4j), что может быть более производительным и логичным для управления связями.

Задание 2. Транзакции

2.1. Пополнение баланса счёта телефона:

Авторизация пользователя
Пользователь вводит свои данные (например, номер телефона и сумму) и авторизуется в системе оплаты (мобильного оператора или банка).

Проверка баланса карты
Система отправляет запрос в банк, чтобы убедиться, что на счете пользователя достаточно средств для выполнения транзакции.

Резервирование суммы
Банк резервирует указанную сумму на счете пользователя, чтобы предотвратить двойные траты и убедиться в наличии средств для последующей оплаты.

Запрос к оператору связи
После подтверждения резервирования система оплаты отправляет запрос оператору связи, чтобы зафиксировать пополнение баланса на указанный номер телефона.

Пополнение баланса
Оператор связи увеличивает баланс счета на указанную сумму и отправляет подтверждение успешного выполнения операции.

Завершение транзакции
После успешного пополнения банк списывает зарезервированные средства с карты пользователя, и обе стороны (банк и оператор) уведомляют пользователя о завершении транзакции (например, через SMS или push-уведомление).

2.1. Пополнение баланса через автоплатёж:*

Проверка настроек автоплатежа
Система проверяет, что автоплатеж активен для указанного пользователя, а также устанавливает параметры (сумма, частота).

Проверка баланса карты
Проводится автоматическая проверка баланса на карте или счету пользователя для выполнения платежа.

Резервирование средств
Система автоматически резервирует сумму на счете пользователя.

Автоматический запрос к оператору
После резервирования средств система автоматически отправляет запрос на пополнение баланса счета телефона у оператора связи.

Пополнение баланса
Оператор связи увеличивает баланс счёта телефона и отправляет подтверждение системе.

Завершение автоплатежа
Система списывает зарезервированные средства с карты или счета пользователя и уведомляет его об успешном завершении транзакции.

Задание 3. SQL vs NoSQL

3.1. Пять преимуществ SQL-систем по отношению к NoSQL:

Гарантии целостности данных (ACID-транзакции)
SQL-системы, как правило, поддерживают ACID (Atomicity, Consistency, Isolation, Durability), что гарантирует высокую надежность и консистентность данных. Это особенно важно для финансовых и критически важных приложений, где данные должны быть всегда точными и целыми.

Строго определённая структура данных
SQL-системы используют реляционную модель данных, где схема базы данных заранее определяется. Это упрощает контроль и поддержку строгой структуры данных, предотвращая ошибки, связанные с несоответствием данных.

Универсальность и зрелость технологий
Реляционные СУБД существуют много лет и широко применяются в самых разных отраслях. Это зрелые и хорошо отлаженные технологии, которые обеспечивают широкий функционал, поддержку сложных запросов и гибкие механизмы управления данными.

Мощные возможности для работы с запросами
SQL предоставляет мощные механизмы для работы с данными, включая сложные соединения (JOIN), подзапросы, агрегатные функции и индексацию. Это позволяет легко и эффективно получать нужные данные из таблиц.

Поддержка стандартизации
SQL является языком, который стандартизирован и поддерживается практически всеми реляционными СУБД. Это упрощает переносимость запросов и данных между разными системами, а также обучение и использование данных технологий.

3.1. Преимущества NewSQL перед SQL и NoSQL:*

Масштабируемость SQL-систем
NewSQL решает проблему горизонтального масштабирования, с которой сталкиваются традиционные SQL-системы. Это позволяет обрабатывать большие объёмы данных и нагрузку, сохраняя при этом поддержку ACID-свойств, чего сложно достичь в классических SQL-СУБД.

Комбинация ACID и высокой производительности
NewSQL-системы предоставляют высокую производительность и низкую задержку, схожую с NoSQL, но при этом сохраняют транзакционные свойства (ACID), что важно для критичных приложений.

Гибкость в структуре данных
Хотя NewSQL ориентирована на реляционные данные, она предлагает гибкость в хранении полуструктурированных данных (например, через поддержку JSON), что делает её конкурентоспособной в задачах, для которых обычно выбираются NoSQL решения.

Простота для разработчиков
В отличие от NoSQL, где разработчикам часто приходится жертвовать схемой данных и сложными запросами, NewSQL сохраняет удобство использования SQL-языка, при этом предлагая производительность и масштабируемость, которые трудно достичь с традиционными SQL-системами.

Консистентность данных в распределённых системах
В отличие от многих NoSQL-систем, которые жертвуют консистентностью ради производительности, NewSQL поддерживает строгую консистентность данных даже в распределённых кластерах, что делает её предпочтительным выбором для критичных приложений с высоким уровнем надёжности данных.

Задание 4. Кластеры

Для выполнения большого количества вычислений при работе с огромным количеством данных, основной критерий выбора типа СУБД будет зависеть от характера данных и задач:

Тип данных
Если данные структурированы и требуют строгой целостности, реляционные SQL-СУБД могут быть предпочтительными (например, распределённые базы данных, такие как CockroachDB или Google Spanner). Однако, если данные менее структурированы или могут включать большие объёмы полуструктурированных данных, NoSQL системы могут быть более подходящими (например, Cassandra, HBase или MongoDB).

Масштабируемость и распределённость
Важным критерием является способность системы эффективно масштабироваться на тысячи машин. СУБД должна быть способна горизонтально масштабироваться и эффективно распределять нагрузку между узлами. NoSQL системы (например, Cassandra или HBase) обеспечивают естественную горизонтальную масштабируемость, что делает их предпочтительными для работы с огромными объёмами данных.

Сложность запросов и аналитика
Если задача включает сложные аналитические вычисления и запросы, стоит рассмотреть распределённые NewSQL решения (например, TiDB или CockroachDB), которые поддерживают как высокую производительность и масштабируемость, так и возможность выполнения сложных SQL-запросов. Если основная цель — это обработка огромных объёмов данных с простой структурой, NoSQL может быть более подходящим выбором.

Consistency vs Availability (CAP-теорема)
Для распределённых вычислений необходимо учитывать компромисс между консистентностью и доступностью (CAP-теорема). В зависимости от задачи может быть выбран баланс между строгой консистентностью (SQL и NewSQL) и доступностью/масштабируемостью (NoSQL).

Модель распределённых вычислений

Наиболее подходящей моделью для работы с огромными объёмами данных будет MapReduce или её современные аналоги, такие как Apache Spark. Это связано с тем, что:

MapReduce позволяет распределять обработку больших объёмов данных на тысячи узлов, что идеально подходит для работы на кластере из 1000 машин.
Apache Spark предоставляет улучшенную версию MapReduce, обеспечивая высокую скорость работы за счёт обработки данных в памяти. Spark также поддерживает интеграцию с различными типами хранилищ (SQL, NoSQL, файловые системы) и позволяет выполнять сложные аналитические задачи.
Spark выделяется тем, что:

Он способен обрабатывать данные в режиме real-time (в отличие от более медленного MapReduce).
Поддерживает распределённую обработку данных на кластере из тысяч машин.
Предоставляет высокую производительность за счёт хранения данных в оперативной памяти (что особенно полезно при большом количестве вычислений).
Почему эта модель лучшая: Spark или MapReduce позволяют эффективно распределять вычисления по узлам, обрабатывать данные в параллельном режиме и масштабироваться по мере роста объёма данных. Эти технологии хорошо справляются с большими объёмами информации и интенсивными вычислениями.
